Допустим что JVM установлена на машине с 64-разряджной ОС. Тогда длина заголовка любого объекта
будет 12 байт (для 32-разрядных ОС - 8 байт соответственно).
1. Создадим объект new User(25, "Ivan").
Рассчитаем размер этого объекта:
1) размер заголовка равен 12 байт;
2) размер поля id равен 4 байт;
3) ссылка на объект String 4 байта. Округляем до 24 байт.
4) размер поля name: пустой объект типа String занимает 24 байт - 8 байт заголовок +
 3 поля типа int по 4 байт + ссылочная переменная на объекта массива - 4 байт
5) объект new char[] в объекте String 24 байта: заголовок 8 байт + длина массива 4 байта +
  содержимое строки Ivan - 4 символа по 2 байт + 4 байта для округления)
  Итого размер объекта: 24 + 24 + 24 = 72 байта

2. Создадим объект new User(25, "Sergey").
Размер данного объекта рассчитывается аналогичным образом и составит также 72 байта.

main-метод:
public static void main(String[] args) {
        info();
        for (int i = 0; i < 10000; i++) {
            new User(i, "N" + i);
        }
        info();
    }

    метод инфо выводит в консоль информацию о памяти, отведенной под heap: свободной, общей и максимально доступной.
    Далее запускается цикл for в котором последовательно создаются 10000 объектов User. Все объекты изначально создаются
    в блоке eden из раздела young generation. Т.к. не создано ни одной ссылки ни на один из
    этих объектов, то все они на протяжении всей своей жизни будут находиться в блоке eden и из него же будут удалены
    путем выполнения minor collection. Если бы на созданные объекты были ссылки, то они перемещались бы в блок Survivor
    раздела young generation при заполнении блока eden. Далее, те из них, которые выжили бы, были бы перемещены
     в блок old generation.